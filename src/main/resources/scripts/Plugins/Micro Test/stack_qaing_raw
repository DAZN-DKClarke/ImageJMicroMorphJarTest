function indexOfValueInArray(lookFor, lookIn) {
	for(checkIndex = 0; checkIndex < lookIn.length; checkIndex++){
		if(lookIn[checkIndex] == lookFor) {
			return checkIndex;
		}
	}

	return -1;

}

function getNumberOfImagesToDisplay() {

	//Ask the user how many images to display on the screen at once for quality control and return this number
	stringa="How many images do you want to display on the screen at once?";
	Dialog.create("Experiment Information");
		
	Dialog.addNumber(stringa,1);
	Dialog.show();
	onScreen = Dialog.getNumber();

	if(onScreen == 0) {
		exit("Images to display can't be zero");
	}

	return(onScreen);

}

function getWorkingAndStorageDirectories(){

    Dialog.create("Pick Directory");
    Dialog.addMessage("Choose morphology analysis working directory");
    Dialog.show();

    setOption("JFileChooser", true);
    workingDirectory = getDirectory("Choose morphology analysis working directory");

    Dialog.create("Pick Directory");
    Dialog.addMessage("Choose the image storage directory");
    Dialog.show();
    //Get the parent 2P directory i.e. where all the raw 2P images are stored
    imageStorage = getDirectory("Choose the image storage directory");
    setOption("JFileChooser", false);

    //Here we create an array to store the full name of the directories we'll be 
    //working with within our morphology processing directory
    directories=newArray(workingDirectory+"Input" + File.separator, 
						workingDirectory+"Output" + File.separator, 
						workingDirectory+"Done" + File.separator,
						imageStorage);
    //[0] is input, [1] is output, [2] is done, [3] is image storage

    directoriesNames = newArray('Input', 'Output', 'Done', 'Image Storage');
    for (i = 0; i < directories.length; i++) {
		print('Directories', directoriesNames[i], ':',  directories[i]);
    }

    images_in_storage = listFilesAndFilesSubDirectories(directories[3], '.tif');
    if(images_in_storage.length == 0) {
    	exit('No .tif images in image storage, exiting plugin');
    }

    return directories;
}

//Function finds all files that contain "substring" in the path "directoryname" 
//"fileLocations" is an array that is passed in to fill with paths that contain substring
function listFilesAndFilesSubDirectories(directoryName, subString) {

	//Get the list of files in the directory
	listOfFiles = getFileList(directoryName);

	//an array to add onto our fileLocations array to extend it so we can keep adding to it
	arrayToConcat = newArray(1);
    fileLocations = newArray(1);

	//Loop through the files in the file list
	for (i=0; i<listOfFiles.length; i++) {

		//Create a string of the full path name
		fullPath = directoryName+listOfFiles[i];
		
		//If the file we're checking is a file and not a directory and if it  contains the substring we're 
		//interested in within its full path we check  against the absolute path of our file in lower case on both counts
		if (File.isDirectory(fullPath)==0 && indexOf(toLowerCase(fullPath), toLowerCase(subString))>-1) {
			
			//We store the full path in the output fileLocations at the latest index 
			//(end of the array) and add an extra bit onto the Array so we can keep filling it
			fileLocations = Array.concat(fileLocations, arrayToConcat);
			currentIndex=fileLocations.length-1;
			fileLocations[currentIndex] = fullPath;

		//If the file we're checking is a directory, then we run the whole thing on that directory
		} else if (File.isDirectory(fullPath)==1) {

			//Create a new array to fill whilst we run on this directory and at the end add it onyo the fileLocations array 
			tempArray = listFilesAndFilesSubDirectories(fullPath, subString);
			fileLocations = Array.concat(fileLocations, tempArray);     
			
		}
	}

	//Create a new array that we fill with all non zero values of fileLocations
	output = removeZeros(fileLocations);

	//Then return the output array
	return output;
	
}

//Get the number of images to display onscreen
onScreen = getNumberOfImagesToDisplay();

//Get user input into where our working directory, and image storage directories, reside
directories = getWorkingAndStorageDirectories();
//[0] is input, [1] is output, [2] is done (working directories) [3] is directoryName (storage directory)

//Get the location of images we've processed
processedStacks = listFilesAndFilesSubDirectories(directories[1], "processed");

//If we already have a table, get out existing values, or create the arrays to fill
tableLoc = directories[1] + "Images to Use.csv";

if(File.exists(tableLoc) == 1) {
	imageList = getTableColumn(tableLoc, "Image List");
	keptList = getTableColumn(tableLoc, "Kept");
	manualFlagList = getTableColumn(tableLoc, "Manual Flag");
} else {
	imageList = newArray(1);
	keptList = newArray(1);
	manualFlagList = newArray(1);
}

// Store the size of the existing table
existingTableLength = imageList.length;

//Count how many images we've opened (so we know when we hit enough to display to the user)
opened = 0;
for(currImage = 0; currImage < processedStacks.length; currImage++) {

	checked = false;
	ignore = true;

	baseImage = substring(Fiile.getName(processedStacks[currImage]), 0, indexOf(processedStacks[currImage], " processed.tif"));
	doneFileLoc = directories[2] + File.getName(baseImage) + ".tif";

	for(currRow = 0; currRow < imageList.length; currRow++) {
		if(File.getName(processedStacks[currImage]) == imageList[currRow]) {
			checked = true;
			kept = keptList[currRow];
			manualFlag = manualFlagList[currRow];
		}
	}

	//Usually we ignore an image if it was previously checked, unless it was also flagged for manual analysis
	//and then processed using manually selected frames
	if(checked == true && kept == 'false' && manualFlag == 'true' && File.exists(doneFileLoc) == 1) {
		ignore = false;
	
	//If the image has not been previously checked, proceed
	} else if(checked == false) {
		ignore = false;
	}

	//If we're QAing the image
	if(ignore == false) {

		windowName = File.getName(processedStacks[currImage]);
		print(windowName);

		//Open each image and add 1 to the count of opened images
		open(processedStacks[currImage]);
		opened++;

		displayImages = false;
		//If we've opened enough images to satisfy our onScreen image value, we print that we've hit the limit
		//and reset the number of images we've opened
		if(opened != 0 && opened == onScreen) {
			print("Hit the limit");
			displayImages = true;
			opened = 0;
		//Otherwise if we're on our final opened image and we don't have enough images open to reach the limit, we print as such
		} else if (currImage==(processedStacks.length-1)) {
			print("Reached end of the directory and not enough images to reach limit");
			displayImages = true;
		}

		//If we've hit our limit or we're done opening images
		if(displayImages == true) {

			setOption("AutoContrast", true);
			//We get a list of all their titles
			allImages = getList("image.titles");
			
			//We tile all the open images, display them to the user, and ask the user to close the ones that don't pass QA
			setBatchMode("Exit and Display");
			run("Tile");
			waitForUser("Close the images that aren't good enough in terms of registration for analysis then press ok");
			openImages = getList("image.titles");

			//We loop through the titles of the images we presented to the user, and if that image is still open,
			//set its kept value to true, else this defaults to false
			keptArray = newArray(allImages.length);
			manualFlagArray = newArray(allImages.length);
			for(checkedImage=0; checkedImage<allImages.length; checkedImage++) {
				manualFlag = 'false';
				kept = 'false';

				for(stillOpen=0; stillOpen<openImages.length; stillOpen++) {
					if(indexOf(toLowerCase(allImages[checkedImage]), toLowerCase(openImages[stillOpen])) > -1) {
						kept = 'true';
						break;
					}
				}

				//If we're not keeping this image
				if(kept == 'false') {
					
					//Find out if that image has had slices manually chosen for it, and if it exists in the done folder
					manualSlicesFile = directories[1] + allImages[checkedImage] + "/Slices To Use.csv";

					//If this image doesn't have a manual registration frame selection file, we flag it for manual analysis and move
					//the image from the done folder to the input folder
					if (File.exists(manualSlicesFile) != 1) {
						manualFlag = 'true';
						wasMoved = File.rename(doneFileLoc, directories[0] + baseImage + ".tif");
						if(wasMoved == 0) {
							print("Issue with moving image to input folder");
							//Could be because its already in input?
						} else {
							print("Image moved from Done to Input");
						}
					}

				}
				
				//Store our kept and manual flag values for this image in arrays
				keptArray[checkedImage] = kept;
				manualFlagArray[checkedImage] = manualFlag;

			}

			//For each image we just approved
			for(checkedImage = 0; checkedImage < allImages.length; checkedImage++) {
				imageFound = false;

				//Check in the existing table values
				for(checkAgainst = 0; checkAgainst < existingTableLength; checkAgainst ++) {

					//If one of the images we just QAd is in the existing table, we update the kept
					//and manualFlag values for that image
					if(allImages[checkedImage] == imageList[checkAginst]) {
						keptList[checkAgainst] = keptArray[checkedImage];
						manualFlagList[checkAgainst] = manualFlagArray[checkedImage];
						imageFound = true;
						break;
					}
				}

				//If the image we QAd wasn't in the existing table, append this to the output from the
				//existing table
				if(imageFound == false) {
					imageList = Array.concat(imageList, newArray(allImages[checkedImage]));
					keptList = Array.concat(keptList, newArray(keptArray[checkedImage]));
					manualFlagList = Array.concat(manualFlagList, newArray(manualFlagArray[checkedImage]));
				}
			}

			//We close all the open images
			if(nImages>0) {
				run("Close All");
			}
				
		}

	}

}

//Remove any zeroes from our arrays where we store the images we've QA'd, the kept values,
//and the manual flag values (this is only necessary if we've made these anew however)
imageList = removeZeroes(imageList);
keptList = removeZeroes(keptList);
manualFlagList = removeZeroes(manualFlagList);

//Save these arrays into a table

