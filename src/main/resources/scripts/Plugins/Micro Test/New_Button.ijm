//This function clears the results table if it exists, clears the roimanager, and closes 
//all open images - useful for quickly clearing the workspace
function Housekeeping() {
	
	if (isOpen("Results")) {
		run("Clear Results");
	}
	if(roiManager("count")>0) {
		roiManager("deselect");
		roiManager("delete");
	}
	if(nImages>0) {
		run("Close All");
	}
}

//Function finds all files that contain "substring" in the path "directoryname" 
//"fileLocations" is an array that is passed in to fill with paths that contain substring
function listFilesAndFilesSubDirectories(directoryName, subString,
                                         fileLocations) {

	//Get the list of files in the directory
	listOfFiles = getFileList(directoryName);

	//an array to add onto our fileLocations array to extend it so we can keep adding to it
	arrayToConcat = newArray(1);

	//Loop through the files in the file list
	for (i=0; i<listOfFiles.length; i++) {

		//Create a string of the full path name
		fullPath = directoryName+listOfFiles[i];
		
		//If the file we're checking is a file and not a directory and if it  contains the substring we're 
		//interested in within its full path we check  against the absolute path of our file in lower case on both counts
		if (File.isDirectory(fullPath)==0 && indexOf(toLowerCase(fullPath), toLowerCase(subString))>-1) {
			
			//We store the full path in the output fileLocations at the latest index 
			//(end of the array) and add an extra bit onto the Array so we can keep filling it
			fileLocations = Array.concat(fileLocations, arrayToConcat);
			currentIndex=fileLocations.length-1;
			fileLocations[currentIndex] = fullPath;

		//If the file we're checking is a directory, then we run the whole thing on that directory
		} else if (File.isDirectory(fullPath)==1) {

			//Create a new array to fill whilst we run on this directory and at the end add it onyo the fileLocations array 
			tempArray= newArray(1);
			tempArray = listFilesAndFilesSubDirectories(fullPath, subString, tempArray);
			fileLocations = Array.concat(fileLocations, tempArray);     
			
		}
	}

	//Create a new array that we fill with all non zero values of fileLocations
	output = newArray(1);

	output = removeZeros(fileLocations, output);

	//Then return the output array
	return output;
	
}

//This function takes an input array, and removes all the 0's in it, outputting 
//it as the output array which must be passed in as an argument
function removeZeros(inputArray, output) {

	//Loop through the input array, if the value isn't a 0, we place that in our 
	//output array (which should be of length 1) before then concatenating an 
	//array of length 1 to it to add another location to store another non-zero 
	//value from the input array
	
	arrayToConcat = newArray(1);

	for(i=0; i<inputArray.length; i++) {
		if(inputArray[i]!=0) {
			currentIndex=output.length-1;
			output[currentIndex]=inputArray[i];
			output = Array.concat(output, arrayToConcat);
		}
	}

	//If the final value of the output array is 0, we trim the array by one
	if(output[output.length-1]==0) {
		output = Array.trim(output, output.length-1);
	}

	return output;
}

//"OutputArray" is an array in which we store the output of this function
//InputName is a string file path of an image generated by this macro
//Function cuts up the file path of the inputName into different segments that
//contain different bits of info i.e. info about the animal and 
//timepoint that we store at index [0] in the array, the timepoint only at [1]
//the animal only at [2] and finally the file name without the .tif on the end that we store at [3]
function getAnimalTimepointInfo(outputArray, inputName) {
  outputArray[0] = File.getName(substring(inputName, 0, indexOf(inputName, " Microglia Morphology")));
  outputArray[1] = toLowerCase(substring(outputArray[0], lastIndexOf(outputArray[0], " ")+1));
  outputArray[2] = toLowerCase(substring(outputArray[0], 0, lastIndexOf(outputArray[0], " ")));
  outputArray[3] = File.getName(substring(inputName, 0, indexOf(inputName, ".tif")));
}

//This is a function to retrieve the data from the ini file. The ini file contains calibration information for the 
//entire experiment that we use to calibrate our images. iniFolder is the folder within which the ini file is located, 
//and iniTextValuesMicrons is an array we pass into the function that we fill with calibration values before returning it
function getIniData(iniFolder, iniTextValuesMicrons) {

	//We get the list of files in the iniFolder
	iniFileList = getFileList(iniFolder);
	
	//Find our ini file
	found = false;
	for(i=0; i<iniFileList.length; i++) {
		if(endsWith(toLowerCase(iniFileList[i]), "ini")) {
			//Create a variable that tells us which ini file to open
			iniToOpen = iniFolder + iniFileList[i]; 
			i = iniFileList.length;
			found = true;
		}
	}
	if(found == false) {
		print("No ini file found");
		return;
	}
	
	//This is an array with the strings that come just before the information we want to retrieve from the ini file.
	iniTextStringsPre = newArray("x.pixel.sz = ", "y.pixel.sz = ", "z.spacing = ", "no.of.planes = ", "frames.per.plane = ");
	
	//This is an array of the length of characters in each iniTextStringsPre item, so we can look this far after the
	//start of each item to find the numeric value
	iniTextIndicesPreAdds = newArray(13, 13, 12, 15, 19);	
		
	//We open the ini file as a string
	iniText = File.openAsString(iniToOpen);	
		
	//Looping through the values we want to grab
	for(i=0; i<iniTextStringsPre.length; i++) {

		//We create a start point that is the index of our iniTextStringsPre + iniTextIndicesPreAdds
		startPoint = indexOf(iniText, iniTextStringsPre[i])+iniTextIndicesPreAdds[i];

		//If we're on the last string, we just grab the whole end from the start of the word "frames"
		if(i == iniTextStringsPre.length-1) {
			realString = substring(iniText, startPoint);

		//Else get it from the start until the start of the next value of interest
		} else {
			realString = substring(iniText, startPoint, indexOf(iniText, iniTextStringsPre[(i+1)]));
		}
		iniTextValuesMicrons[i] = parseFloat(realString);
	}
}

//Part of motion processing, takes an array (currentStackSlices), removes zeros from it, then
//creates a string of the numbers in the array before then making a substack of these slices
//from an imagesInput[i] window, registering them if necessary, before renaming them
//according to the info in motionArtifactRemoval
function getAndProcessSlices(currenStackSlices, motionArtifactRemoval, currTime) {
	
	//Here we order then cutoff the zeros so we get a small array of the 
	//slices to be retained
	imageNumberArrayCutoff = newArray(1);
	imageNumberArrayCutoff=removeZeros(currenStackSlices, imageNumberArrayCutoff);

	selectWindow("Timepoint");	
	timeSlices = nSlices;
					
	//This loop strings together the names stored in the arrayIn into a 
	//concatenated string (called strung) that can be input into the substack 
	//maker function so that we can make a substack of all kept TZ slices in
	//a single go - we input the imageNumberArrayCutoff array
	strung="";
	for(i1=0; i1<imageNumberArrayCutoff.length; i1++) {
		
		numb = imageNumberArrayCutoff[i1] - (currTime * timeSlices);
		string=toString(numb, 0);
						
		//If we're not at the end of the array, we separate our values with a 
		//comma
		if(i1<imageNumberArrayCutoff.length-1) {
			strung += string + ",";
	
		//Else if we are, we don't add anything to the end
		} else if (i1==imageNumberArrayCutoff.length-1) {
			strung += string;	
		}
	
	}
	
	//We then make a substack of our input image of the slices we're keeping 
	//for this particular ZT point
	selectWindow("Timepoint");	
	run("Make Substack...", "slices=["+strung+"]");
	rename("new");
	selectWindow("new");
	newSlices = nSlices;
		
	//If the image has more than 1 slice, register it and average project it 
	//so that we get a single image for this ZT point
	if(newSlices>1){
						
		print("Registering T", motionArtifactRemoval[2], " Z", motionArtifactRemoval[3]);
		if(false) {
		run("MultiStackReg", "stack_1=[new] action_1=Align file_1=[]  stack_2=None action_2=Ignore file_2=[] transformation=[Translation]");
		run("MultiStackReg", "stack_1=[new] action_1=Align file_1=[]  stack_2=None action_2=Ignore file_2=[] transformation=[Affine]");
		}
		print("Registered");
						
		selectWindow("new");
		rename("T"+motionArtifactRemoval[2]+" Z"+motionArtifactRemoval[3]);
		run("Z Project...", "projection=[Average Intensity]");
		selectWindow("T"+motionArtifactRemoval[2]+" Z"+motionArtifactRemoval[3]);
		run("Close");
		selectWindow("AVG_T"+motionArtifactRemoval[2]+" Z"+motionArtifactRemoval[3]);
		rename("T"+motionArtifactRemoval[2]+" Z"+motionArtifactRemoval[3]);	
		
	//Otherwise just rename it appropriately
	} else {	
		selectWindow("new");
		rename("T"+motionArtifactRemoval[2]+" Z"+motionArtifactRemoval[3]);	
	}

}

//Function to incorporate the reordering of Z slices in registration. Takes an 
//inputImage, then rearranges slices that are maximally layersToTest apart 
//before renaming it toRename
function zSpaceCorrection(inputImage, layersToTest, toRename) {

	//Array to store the name of output images from the spacing correction to 
	//close
	toClose = newArray("Warped", "Image", inputImage);

	//Runs the z spacing correction plugin on the input image using the 
	//layersToTest value as the maximum number of layers to check against for z 
	//positioning
	selectWindow(inputImage);
	run("Z-Spacing Correction", "input=[] type=[Image Stack] text_maximally="+layersToTest+" outer_iterations=100 outer_regularization=0.40 inner_iterations=10 inner_regularization=0.10 allow_reordering number=1 visitor=lazy similarity_method=[NCC (aligned)] scale=1.000 voxel=1.0000 voxel_0=1.0000 voxel_1=1.0000 render voxel=1.0000 voxel_0=1.0000 voxel_1=1.0000 upsample=1");

	//Closes any images that are in the toClose array first by getting a list of 
	//the image titles that exist
	imageTitleList = getList("image.titles");

	//Then we loop through the titles of the images we want to close, each time 
	//also looping through the images that are open
	for(k = 0; k<toClose.length; k++) {
		for(j=0; j<imageTitleList.length; j++) {
			
			//If the title of the currently selected open image matches the one we 
			//want to close, then we close that image and terminate our search of the 
			//current toClose title in our list of images and move onto the next 
			//toClose title
			if(indexOf(imageTitleList[j], toClose[k]) == 0) {
				selectWindow(imageTitleList[j]);
				run("Close");
				j = imageTitleList.length;
			}
		}
	}

	//Renames the output image to the toRename variable
	selectWindow("Z-Spacing: " + inputImage);
	rename(toRename);

	//Close the exception that is thrown by the rearranging of stacks
	selectWindow("Exception");
	run("Close");

}

//This is a function used to fill an inputArray using data from a csv file 
//referenced in resultsTableRefs, from a column referenced in 
//resultsTableColumns, and whether that column contains strings are stored in 
//resultsAreStrings, and finally the argument inputsAreArrays can be set to true 
//if we're referencing multiple columns and multiple results tables to store in 
//a single inputArray

//InputArray needs to be a multiple of resultsTableRefs.length since if we have 
//multiple resultsTableRefs values, we need to store at least that many values 
//in the inputArray
function fillArray(inputArray, resultsTableRefs, resultsTableColumns, 
	resultsAreStrings, inputsAreArrays) {
	
	//Clear the results table, check if our results table to load exists
	run("Clear Results");
	
	//Here if we are referencing multiple columns then inputsAreArrays will be 
	//true
	if(inputsAreArrays == true) {

		//The section of the inputArray that we want to dedicate to each results 
		//value is calculated
		sizePerSection = inputArray.length / resultsTableRefs.length;

		//Then loopping through the different data we want to fill our inputArray 
		//with
		for(i=0; i<resultsTableRefs.length; i++) {
			
			//We first clear results, then if our resultsTableRefs file exists, we 
			//open it 
			run("Clear Results");
			if(File.exists(resultsTableRefs[i])==1) {
				open(resultsTableRefs[i]);
				tabName = Table.title;
				
				//Looping through the section of our inputArray that we're filling
				for(i0=0; i0<sizePerSection; i0++) {

					//If our current results we're getting aren't a string and we are 
					//still within the limits of the results table then we fill our 
					//inputArray with the result associated with our resultsTableColumns
					if(resultsAreStrings[i]==false && i0 < Table.size) {
						inputArray[(i*sizePerSection)+i0] = Table.get(resultsTableColumns[i] 
						                                              ,i0);

					//Otherwise if it is a string then we use getResultString
					} else if (i0<Table.size) {
						inputArray[(i*sizePerSection)+i0] = 
						getResultString(resultsTableColumns[i], i0);
					
					//Otherwise if we're past the size of our results table, we fill our 
					//inputArray with a 0
					} else {
						inputArray[(i*sizePerSection)+i0] = 0;
					}
				}
				selectWindow(tabName);
				Table.reset(tabName);
				run("Clear Results");
			}
			//Table.reset(File.getName(resultsTableRefs[i]));
		}

	//If we're not getting multiple columns
	} else {

		//Check if our results table actually exists
		if(File.exists(resultsTableRefs)==1) {
			
			//Open our results table then loop through the results, filling our 
			//inputArray with the data depending on if its a string or not
			open(resultsTableRefs);
			tabName = Table.title;
			
			//Loop through the results table and fill the input array with the 
			//information we want to get
			for(i0=0; i0<Table.size; i0++) {
				if(resultsAreStrings==false) {
					inputArray[i0] = Table.get(resultsTableColumns, i0);
				} else {
					inputArray[i0] = Table.getString(resultsTableColumns, i0);
				}
			}
			selectWindow(tabName);
			Table.reset(tabName);
			run("Clear Results");	
		}
		
	}
}

//This is a function that generates a waitForUser dialog with waitForUserDialog 
//that then retrieves a checkbox value with the string checkboxString so that 
//the user can check an image and then return feedback for a given string
function userApproval(waitForUserDialog, dialogName, checkboxString) {

	//We zoom into an image 3 times so that its bigger on the screen for the user 
	//to check
	for(i=0; i<3; i++) {
		run("In [+]");
	}

	//Scale the image to fit, before exiting and displaying hidden images from 
	//batch mode, autocontrasting the image, then waiting for the user				
	run("Scale to Fit");					
	setBatchMode("Exit and Display");
	setOption("AutoContrast", true);
	waitForUser(waitForUserDialog);

	//Once exiting the wait for user dialog we ask the user to give feedback 
	//through a dialog box and then return the checkbox boolean value						
	Dialog.create(dialogName);
	Dialog.addCheckbox(checkboxString, true);
	Dialog.show();
	output = Dialog.getCheckbox();
	return output;
}

//This function finds the area of a mask that is above a certain threshold value
//(threshValue) and connected to a point with coordinates xPoint, yPoint
function getConnectedArea(xPoint, yPoint, threshValue) {

	
	//We make the point on our image then use the find connected regions plugin to 
	//generate an image of all the pixels connected to that coordinate that have a
	//grey value above threshValue
	makePoint(xPoint, yPoint);
	setBackgroundColor(0,0,0);
	run("Find Connected Regions", "allow_diagonal display_image_for_each start_from_point regions_for_values_over="+threshValue+" minimum_number_of_points=1 stop_after=1");
	
	//Get the area of the mask generated and return it, leaving the mask open so 
	//that we can grab it outside the function for further manipulation
	imgNamemask=getTitle();
	selectWindow(imgNamemask);
	run("Select None");
	run("Invert");
	run("Create Selection");
	getStatistics(area);

	return area;

}

//This function essentially checks if a mask is touching the edges of the canvas
//that it is contained within. It's behaviour varies depending on the type 
//argument. It acts to determine whether a microglia cell mask is touching the
//edges of the local area around it, and returns whether to keep iteratively
//thresholding the cell mask or not depending on the context as follows:

//Below lower limit description: 
//Function decides whether to continue iteratively thresholding a mask that has 
//an area below threshold by checking if it touches edges, if so, we stop 
//processing this cell, otherwise continue where threshContinueF is binary and 1
//if you should continue thresholding

//Within range description: 
//Function does the same as above but for a cell that falls within range of 
//desired areas - i.e. within +/- range of the current TCS. If not touching, the
//mask is saved and we move to next cell, otherwise we continue iterating in the
//hope we find a threshold value that satistifies the TCS and range and that 
//means it isn't touching the edge

//Stabilized description: 
//Function checks cell masks that have stabilized for 3 iterations, if they are 
//touching an edge they are disregarded, otherwise saved, either way we move 
//onto the next cell afterwards i.e. we save cell masks that are TCS +/- range, 
//or that have reached a stable area for 3 iterations and that this mask isn't 
//touching the edges

//Args: imageName is the mask to check whether its touching the edges of the LR, 
//saveName is where to save it if we want to, fileName is what to save it as, 
//and type is what kind of check we're running where 0 is whether the mask 
//touches an edge whilst the size of the mask is below the lower size limit, 1 
//is to check it touches whilst its within our desired area range, and 2 is to 
//check once the image area has stabilized

function touchingCheck(imageName, saveName, fileName, type) {

	//These are arrays of strings that we're going to print out to inform the user 
	//of the decision of this function, what we print will come from 
	//firstStringArray if the mask isn't touching the edges of the image and the 
	//secondStringArray if it is, which string index depends on the type of check 
	//we're running
	firstStringArray = newArray("", 
	                            "Cell within limits and not touching edges, saving", 
	                            "Cell size stabilized and didn't touch edges, saving");
	secondStringArray =  newArray("High threshold / low area mask touches edges already, ignoring cell", 
	                              "Cell within limits but touches edges, resuming iterative thresholding", 
	                              "Cell size stabilized but touches edges, ignoring");

	//Takes the mask of the cell and turns it into its bounding quadrilateral, 
	//then gets an array of all the coordinates of that quadrilateral
	selectWindow(imageName);
	run("Create Selection");
	run("To Bounding Box");
	getSelectionCoordinates(xF,yF);

	//Get out the number of coordinates i.e. pixels in the selection and then 
	//create a single array, selectionCoords, to store all the coordinates
	xFLength = xF.length;
	selectionCoords = Array.concat(xF, yF);

	//The distance in image units that we use as a buffer around the edges of our 
	//image - i.e., if our image is within "distance" of the edges of our image, 
	//we say its touching the edges
	distance = 5;

	//Get out the width and height of the input image and create a new array to 
	//store whether the mask touches the edges, and the maximum possible Y and X 
	//coordinates that the selection can be to avoid coming within "distance" of 
	//the edges of the image
	getDimensions(functionWidth, functionHeight, functionChannels, functionSlices, functionFrames);
	coordinatesArray = newArray(false, functionHeight-distance, functionWidth-distance);
	//[0] is touching, [1] is newHeightF, [2] is newWidthF

	//Loop through the coordinates of the selection
	for (i=0; i<xF.length; i++) {

		//If the x coordinate at that point is <= distance, then the mask touches, 
		//if it is >= the maximum x value it can be without touching, then it touches
		//If the y coordinates is <= distance then it touches, if it is >= maximum 
		//possible y value then it touches
		if(selectionCoords[i]<=distance || selectionCoords[i]>=coordinatesArray[2] || 
		   selectionCoords[i+xFLength]<=distance || 
		   selectionCoords[i+xFLength]>=coordinatesArray[1]) {
			
			//Set [0] to true since the selection touches the edges and stop checking 
			//for touching, since only one coordinate has to be close enough
			coordinatesArray[0] = true;
			i = xF.length;
			
			//Print out that the mask touches the edges and depending on the type of 
			//check we're running, the appropriate conclusion
			print(secondStringArray[type]);

			//If we're checking for touching below the area limits or once the image 
			//has stabilized, touching means we disregard this cell and so we set 
			//output to false
			if(type==0 || type == 2) {
				output = false; 

			//Otherwise if we're checking for a cell within the area limits, this 
			//isn't necessarily the only outcome so we set output to true to continue
			//iterating to try and find a new threshold value that means we're in the 
			//limits but not touching
			} else if (type ==1) {
				output = true;
			}
			
		}
		
	}

	//If the mask isn't touching, we print out the appropriate message for the 
	//type of check we're doing
	if(coordinatesArray[0]==false) {
		print(firstStringArray[type]);

		//If the image is below the area limit, we continue threshold iterations
		if(type==0) {
			output = true;

		//Otherwise if the image is within the area limits or has a stabilised area, 
		//we clear our selection, and save the image using the saveName and fileName
		//inputs before setting output to false as we're now done with this cell
		} else if (type==1 || type==2) {
			selectWindow(imageName);
			run("Select None");
			saveAs("tiff", saveName);
			selectWindow(fileName);
			rename(imageName);
			output = false;
		}
	}

	//Return our output value
	return output;
}

//Function to check if the inputValue is above the topLimit - this is so that if 
//our thresholding calculated value ends up above the highest grey value in the 
//image then we set inputValue to that top value
function valueCheck(inputValue, topLimit) {
	
	if(inputValue>=topLimit) {
		inputValue = topLimit-1;
	}

	//We want a rounded threshold value since the images are in 8-bit, so we do 
	//that before returning it
	return round(inputValue);
}

function checkForSameCell(nameArray, currentCell, keptArray, currentKeptDefault,  currentCheckDefault, xCoord, yCoord, substackLoc, somaFolder, returnArray) {

	currentKept = currentKeptDefault;
	currentCheck = currentCheckDefault;
								
	//For each cell, get its x, y, and substack location
	for(i1 = 0; i1<nameArray.length; i1++) {
		newxCoord = parseInt(substring(nameArray[i1], indexOf(nameArray[i1], "x ")+2, indexOf(nameArray[i1], "y")-1));
		newyCoord = parseInt(substring(nameArray[i1], indexOf(nameArray[i1], "y ")+2, indexOf(nameArray[i1], ".tif")-1));
		newsubstackLoc = substring(nameArray[i1], 0, indexOf(nameArray[i1], "x"));

		//If the current cell in the current TCS matches a cell in the previous TCS, set whether to keep it
		//to whether the cell was kept previously
		if(currentCell == nameArray[i1]) {
			currentKept = keptArray[i1];
			currentCheck = 1;
			print("found ", keptArray[i1]);
			i1 = 1e99;
										
		//Otherwise if its not got the same name as the previous cell, but its coordinates are within 10 of it,
		//set the otherSomaName to the soma name associated with this previous cell
		} else if(abs(xCoord-newxCoord) <= 10 && abs(yCoord-newyCoord) <= 10 && newsubstackLoc == substackLoc) {
			currentKept = keptArray[i1];
			print(currentCell);
			print(nameArray[i1]);
			otherSomaName = somaFolder + "Candidate Soma Mask for " + substring(nameArray[i1], indexOf(nameArray[i1], "Substack"));
			print(otherSomaName);
			i1 = 1e99;
			currentCheck = 1;
		}
	}
	returnArray[0] = currentKept;
	returnArray[1] = currentCheck;
	returnArray[2] = otherSomaName;
	return returnArray;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////// Main user input sections //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//A string array that contains the functionality choices that the user has wrt. 
//running this macro
stringChoices = newArray("Preprocess morphology stacks and save them", "QC Motion Processing",
	"Mark cell positions", "Generate masks for cells", 
	"Quality control masks", "Analyse masks");

//Create a dialog box where the user can input which functionalities they want 
//to run
Dialog.create("Analysis Selection");
Dialog.show();